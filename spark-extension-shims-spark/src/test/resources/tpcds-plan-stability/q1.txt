== Physical Plan ==
AdaptiveSparkPlan (55)
+- TakeOrderedAndProject (54)
   +- Project (53)
      +- SortMergeJoin Inner (52)
         :- Sort (47)
         :  +- Exchange (46)
         :     +- Project (45)
         :        +- SortMergeJoin Inner (44)
         :           :- Project (38)
         :           :  +- SortMergeJoin Inner (37)
         :           :     :- Sort (17)
         :           :     :  +- Exchange (16)
         :           :     :     +- Filter (15)
         :           :     :        +- HashAggregate (14)
         :           :     :           +- Exchange (13)
         :           :     :              +- HashAggregate (12)
         :           :     :                 +- Project (11)
         :           :     :                    +- SortMergeJoin Inner (10)
         :           :     :                       :- Sort (4)
         :           :     :                       :  +- Exchange (3)
         :           :     :                       :     +- Filter (2)
         :           :     :                       :        +- Scan parquet  (1)
         :           :     :                       +- Sort (9)
         :           :     :                          +- Exchange (8)
         :           :     :                             +- Project (7)
         :           :     :                                +- Filter (6)
         :           :     :                                   +- Scan parquet  (5)
         :           :     +- Sort (36)
         :           :        +- Filter (35)
         :           :           +- HashAggregate (34)
         :           :              +- Exchange (33)
         :           :                 +- HashAggregate (32)
         :           :                    +- HashAggregate (31)
         :           :                       +- Exchange (30)
         :           :                          +- HashAggregate (29)
         :           :                             +- Project (28)
         :           :                                +- SortMergeJoin Inner (27)
         :           :                                   :- Sort (21)
         :           :                                   :  +- Exchange (20)
         :           :                                   :     +- Filter (19)
         :           :                                   :        +- Scan parquet  (18)
         :           :                                   +- Sort (26)
         :           :                                      +- Exchange (25)
         :           :                                         +- Project (24)
         :           :                                            +- Filter (23)
         :           :                                               +- Scan parquet  (22)
         :           +- Sort (43)
         :              +- Exchange (42)
         :                 +- Project (41)
         :                    +- Filter (40)
         :                       +- Scan parquet  (39)
         +- Sort (51)
            +- Exchange (50)
               +- Filter (49)
                  +- Scan parquet  (48)


(1) Scan parquet 
Output [4]: [sr_returned_date_sk#1, sr_customer_sk#2, sr_store_sk#3, sr_return_amt#4]
Batched: true
Location: InMemoryFileIndex [file:/<warehouse_dir>]
PushedFilters: [IsNotNull(sr_returned_date_sk), IsNotNull(sr_store_sk), IsNotNull(sr_customer_sk)]
ReadSchema: struct<sr_returned_date_sk:int,sr_customer_sk:int,sr_store_sk:int,sr_return_amt:decimal(7,2)>

(2) Filter
Input [4]: [sr_returned_date_sk#1, sr_customer_sk#2, sr_store_sk#3, sr_return_amt#4]
Condition : ((isnotnull(sr_returned_date_sk#1) AND isnotnull(sr_store_sk#3)) AND isnotnull(sr_customer_sk#2))

(3) Exchange
Input [4]: [sr_returned_date_sk#1, sr_customer_sk#2, sr_store_sk#3, sr_return_amt#4]
Arguments: hashpartitioning(sr_returned_date_sk#1, 5), ENSURE_REQUIREMENTS, [plan_id=1]

(4) Sort
Input [4]: [sr_returned_date_sk#1, sr_customer_sk#2, sr_store_sk#3, sr_return_amt#4]
Arguments: [sr_returned_date_sk#1 ASC NULLS FIRST], false, 0

(5) Scan parquet 
Output [2]: [d_date_sk#5, d_year#6]
Batched: true
Location: InMemoryFileIndex [file:/<warehouse_dir>]
PushedFilters: [IsNotNull(d_year), EqualTo(d_year,2000), IsNotNull(d_date_sk)]
ReadSchema: struct<d_date_sk:int,d_year:int>

(6) Filter
Input [2]: [d_date_sk#5, d_year#6]
Condition : ((isnotnull(d_year#6) AND (d_year#6 = 2000)) AND isnotnull(d_date_sk#5))

(7) Project
Output [1]: [d_date_sk#5]
Input [2]: [d_date_sk#5, d_year#6]

(8) Exchange
Input [1]: [d_date_sk#5]
Arguments: hashpartitioning(d_date_sk#5, 5), ENSURE_REQUIREMENTS, [plan_id=2]

(9) Sort
Input [1]: [d_date_sk#5]
Arguments: [d_date_sk#5 ASC NULLS FIRST], false, 0

(10) SortMergeJoin
Left keys [1]: [sr_returned_date_sk#1]
Right keys [1]: [d_date_sk#5]
Join type: Inner
Join condition: None

(11) Project
Output [3]: [sr_customer_sk#2, sr_store_sk#3, sr_return_amt#4]
Input [5]: [sr_returned_date_sk#1, sr_customer_sk#2, sr_store_sk#3, sr_return_amt#4, d_date_sk#5]

(12) HashAggregate
Input [3]: [sr_customer_sk#2, sr_store_sk#3, sr_return_amt#4]
Keys [2]: [sr_customer_sk#2, sr_store_sk#3]
Functions [1]: [partial_sum(UnscaledValue(sr_return_amt#4))]
Aggregate Attributes [1]: [sum#7]
Results [3]: [sr_customer_sk#2, sr_store_sk#3, sum#8]

(13) Exchange
Input [3]: [sr_customer_sk#2, sr_store_sk#3, sum#8]
Arguments: hashpartitioning(sr_customer_sk#2, sr_store_sk#3, 5), ENSURE_REQUIREMENTS, [plan_id=3]

(14) HashAggregate
Input [3]: [sr_customer_sk#2, sr_store_sk#3, sum#8]
Keys [2]: [sr_customer_sk#2, sr_store_sk#3]
Functions [1]: [sum(UnscaledValue(sr_return_amt#4))]
Aggregate Attributes [1]: [sum(UnscaledValue(sr_return_amt#4))#9]
Results [3]: [sr_customer_sk#2 AS ctr_customer_sk#10, sr_store_sk#3 AS ctr_store_sk#11, MakeDecimal(sum(UnscaledValue(sr_return_amt#4))#9,17,2) AS ctr_total_return#12]

(15) Filter
Input [3]: [ctr_customer_sk#10, ctr_store_sk#11, ctr_total_return#12]
Condition : isnotnull(ctr_total_return#12)

(16) Exchange
Input [3]: [ctr_customer_sk#10, ctr_store_sk#11, ctr_total_return#12]
Arguments: hashpartitioning(ctr_store_sk#11, 5), ENSURE_REQUIREMENTS, [plan_id=4]

(17) Sort
Input [3]: [ctr_customer_sk#10, ctr_store_sk#11, ctr_total_return#12]
Arguments: [ctr_store_sk#11 ASC NULLS FIRST], false, 0

(18) Scan parquet 
Output [4]: [sr_returned_date_sk#13, sr_customer_sk#14, sr_store_sk#15, sr_return_amt#16]
Batched: true
Location: InMemoryFileIndex [file:/<warehouse_dir>]
PushedFilters: [IsNotNull(sr_returned_date_sk), IsNotNull(sr_store_sk)]
ReadSchema: struct<sr_returned_date_sk:int,sr_customer_sk:int,sr_store_sk:int,sr_return_amt:decimal(7,2)>

(19) Filter
Input [4]: [sr_returned_date_sk#13, sr_customer_sk#14, sr_store_sk#15, sr_return_amt#16]
Condition : (isnotnull(sr_returned_date_sk#13) AND isnotnull(sr_store_sk#15))

(20) Exchange
Input [4]: [sr_returned_date_sk#13, sr_customer_sk#14, sr_store_sk#15, sr_return_amt#16]
Arguments: hashpartitioning(sr_returned_date_sk#13, 5), ENSURE_REQUIREMENTS, [plan_id=5]

(21) Sort
Input [4]: [sr_returned_date_sk#13, sr_customer_sk#14, sr_store_sk#15, sr_return_amt#16]
Arguments: [sr_returned_date_sk#13 ASC NULLS FIRST], false, 0

(22) Scan parquet 
Output [2]: [d_date_sk#17, d_year#18]
Batched: true
Location: InMemoryFileIndex [file:/<warehouse_dir>]
PushedFilters: [IsNotNull(d_year), EqualTo(d_year,2000), IsNotNull(d_date_sk)]
ReadSchema: struct<d_date_sk:int,d_year:int>

(23) Filter
Input [2]: [d_date_sk#17, d_year#18]
Condition : ((isnotnull(d_year#18) AND (d_year#18 = 2000)) AND isnotnull(d_date_sk#17))

(24) Project
Output [1]: [d_date_sk#17]
Input [2]: [d_date_sk#17, d_year#18]

(25) Exchange
Input [1]: [d_date_sk#17]
Arguments: hashpartitioning(d_date_sk#17, 5), ENSURE_REQUIREMENTS, [plan_id=6]

(26) Sort
Input [1]: [d_date_sk#17]
Arguments: [d_date_sk#17 ASC NULLS FIRST], false, 0

(27) SortMergeJoin
Left keys [1]: [sr_returned_date_sk#13]
Right keys [1]: [d_date_sk#17]
Join type: Inner
Join condition: None

(28) Project
Output [3]: [sr_customer_sk#14, sr_store_sk#15, sr_return_amt#16]
Input [5]: [sr_returned_date_sk#13, sr_customer_sk#14, sr_store_sk#15, sr_return_amt#16, d_date_sk#17]

(29) HashAggregate
Input [3]: [sr_customer_sk#14, sr_store_sk#15, sr_return_amt#16]
Keys [2]: [sr_customer_sk#14, sr_store_sk#15]
Functions [1]: [partial_sum(UnscaledValue(sr_return_amt#16))]
Aggregate Attributes [1]: [sum#19]
Results [3]: [sr_customer_sk#14, sr_store_sk#15, sum#20]

(30) Exchange
Input [3]: [sr_customer_sk#14, sr_store_sk#15, sum#20]
Arguments: hashpartitioning(sr_customer_sk#14, sr_store_sk#15, 5), ENSURE_REQUIREMENTS, [plan_id=7]

(31) HashAggregate
Input [3]: [sr_customer_sk#14, sr_store_sk#15, sum#20]
Keys [2]: [sr_customer_sk#14, sr_store_sk#15]
Functions [1]: [sum(UnscaledValue(sr_return_amt#16))]
Aggregate Attributes [1]: [sum(UnscaledValue(sr_return_amt#16))#9]
Results [2]: [sr_store_sk#15 AS ctr_store_sk#21, MakeDecimal(sum(UnscaledValue(sr_return_amt#16))#9,17,2) AS ctr_total_return#22]

(32) HashAggregate
Input [2]: [ctr_store_sk#21, ctr_total_return#22]
Keys [1]: [ctr_store_sk#21]
Functions [1]: [partial_avg(ctr_total_return#22)]
Aggregate Attributes [2]: [sum#23, count#24]
Results [3]: [ctr_store_sk#21, sum#25, count#26]

(33) Exchange
Input [3]: [ctr_store_sk#21, sum#25, count#26]
Arguments: hashpartitioning(ctr_store_sk#21, 5), ENSURE_REQUIREMENTS, [plan_id=8]

(34) HashAggregate
Input [3]: [ctr_store_sk#21, sum#25, count#26]
Keys [1]: [ctr_store_sk#21]
Functions [1]: [avg(ctr_total_return#22)]
Aggregate Attributes [1]: [avg(ctr_total_return#22)#27]
Results [2]: [(avg(ctr_total_return#22)#27 * 1.2) AS (avg(ctr_total_return) * 1.2)#28, ctr_store_sk#21]

(35) Filter
Input [2]: [(avg(ctr_total_return) * 1.2)#28, ctr_store_sk#21]
Condition : isnotnull((avg(ctr_total_return) * 1.2)#28)

(36) Sort
Input [2]: [(avg(ctr_total_return) * 1.2)#28, ctr_store_sk#21]
Arguments: [ctr_store_sk#21 ASC NULLS FIRST], false, 0

(37) SortMergeJoin
Left keys [1]: [ctr_store_sk#11]
Right keys [1]: [ctr_store_sk#21]
Join type: Inner
Join condition: (cast(ctr_total_return#12 as decimal(24,7)) > (avg(ctr_total_return) * 1.2)#28)

(38) Project
Output [2]: [ctr_customer_sk#10, ctr_store_sk#11]
Input [5]: [ctr_customer_sk#10, ctr_store_sk#11, ctr_total_return#12, (avg(ctr_total_return) * 1.2)#28, ctr_store_sk#21]

(39) Scan parquet 
Output [2]: [s_store_sk#29, s_state#30]
Batched: true
Location: InMemoryFileIndex [file:/<warehouse_dir>]
PushedFilters: [IsNotNull(s_state), EqualTo(s_state,TN), IsNotNull(s_store_sk)]
ReadSchema: struct<s_store_sk:int,s_state:string>

(40) Filter
Input [2]: [s_store_sk#29, s_state#30]
Condition : ((isnotnull(s_state#30) AND (s_state#30 = TN)) AND isnotnull(s_store_sk#29))

(41) Project
Output [1]: [s_store_sk#29]
Input [2]: [s_store_sk#29, s_state#30]

(42) Exchange
Input [1]: [s_store_sk#29]
Arguments: hashpartitioning(s_store_sk#29, 5), ENSURE_REQUIREMENTS, [plan_id=9]

(43) Sort
Input [1]: [s_store_sk#29]
Arguments: [s_store_sk#29 ASC NULLS FIRST], false, 0

(44) SortMergeJoin
Left keys [1]: [ctr_store_sk#11]
Right keys [1]: [s_store_sk#29]
Join type: Inner
Join condition: None

(45) Project
Output [1]: [ctr_customer_sk#10]
Input [3]: [ctr_customer_sk#10, ctr_store_sk#11, s_store_sk#29]

(46) Exchange
Input [1]: [ctr_customer_sk#10]
Arguments: hashpartitioning(ctr_customer_sk#10, 5), ENSURE_REQUIREMENTS, [plan_id=10]

(47) Sort
Input [1]: [ctr_customer_sk#10]
Arguments: [ctr_customer_sk#10 ASC NULLS FIRST], false, 0

(48) Scan parquet 
Output [2]: [c_customer_sk#31, c_customer_id#32]
Batched: true
Location: InMemoryFileIndex [file:/<warehouse_dir>]
PushedFilters: [IsNotNull(c_customer_sk)]
ReadSchema: struct<c_customer_sk:int,c_customer_id:string>

(49) Filter
Input [2]: [c_customer_sk#31, c_customer_id#32]
Condition : isnotnull(c_customer_sk#31)

(50) Exchange
Input [2]: [c_customer_sk#31, c_customer_id#32]
Arguments: hashpartitioning(c_customer_sk#31, 5), ENSURE_REQUIREMENTS, [plan_id=11]

(51) Sort
Input [2]: [c_customer_sk#31, c_customer_id#32]
Arguments: [c_customer_sk#31 ASC NULLS FIRST], false, 0

(52) SortMergeJoin
Left keys [1]: [ctr_customer_sk#10]
Right keys [1]: [c_customer_sk#31]
Join type: Inner
Join condition: None

(53) Project
Output [1]: [c_customer_id#32]
Input [3]: [ctr_customer_sk#10, c_customer_sk#31, c_customer_id#32]

(54) TakeOrderedAndProject
Input [1]: [c_customer_id#32]
Arguments: X, [c_customer_id#32 ASC NULLS FIRST], [c_customer_id#32]

(55) AdaptiveSparkPlan
Output [1]: [c_customer_id#32]
Arguments: isFinalPlan=false

